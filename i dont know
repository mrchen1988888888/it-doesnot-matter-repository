<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
px 15px; color: white;
            font-family: monospace; font-size: 14px;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
            opacity: 0.7;
        }
        .hud-item.active {
            border-left-color: #ff0055;
            background: rgba(40, 0, 2    <title>3Dæ‰‹åŠ¿ç²’å­(æŒ‡æŒ¥å®˜ç‰ˆ)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000; font-family: -apple-system, sans-serif; }
        
        #input-video { 
            position: absolute; top: 0;0, 0.8);
            opacity: 1; transform: scale(1.05); transform-origin: left;
            box-shadow: 0 0 15px rgba(255 left: 0; width: 100%; height: 100%; 
            opacity: 0; pointer-events: none; z-index: -1; 
            transform: scaleX(-, 0, 85, 0.3);
        }

        /* çŠ¶æ€æç¤ºå¤§å­— */
        #mode-display {
            position: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            font-size: 24px; font-weight: bold; color: #00ff1); 
        }
        
        /* HUD ä»ªè¡¨ç›˜ */
        #hud-container {
            position: absolute; top: 20px; left: 20px;
            display: flex; flex-direction: column; gap: 10px;
            pointer-events: none; z-index:88;
            text-shadow: 0 0 10px rgba(0,255,1 90;
        }
        
        .hud-item {
            background: rgba(0, 236,0.5);
            background: rgba(0,0,0,0.5); padding: 5px 20px; border-radius: 20px;
            pointer-events: none; z-index: 50;
            transition: all 0.3s;
        }0, 40, 0.7);
            border-left: 3px solid #00ff88;
            padding: 8px 15px; color: #fff;
            font-family: 'Courier New
        #mode-display.paused { color: #ff3333; text-shadow: 0 0 10px rgba(255,51,51,0.5); }

        /* ', monospace; font-size: 14px;
            text-shadow: 0 0 5px rgba(0, 255, 136, 0.5);
            transition: all 0.3s;
            opacity: 0.7;
        }
        .hud-item.active {
åº•éƒ¨æ“ä½œæŒ‡å¼• */
        #guide-panel {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 600px;
            background: rgba(10, 10, 10, 0            opacity: 1; border-color: #00ffff;
            background: rgba(0, 40, 80, 0.9);
            transform: scale(1.05); transform-origin: left;
        }
        
        /* çŠ¶æ€æç¤ºå¤§å­— */
        #mode-indicator {
            position.85);
            border-radius: 15px; padding: 15px;
            color: #ccc; font-size: 12px;
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
            pointer-events: none; z-index: 50;
            border: 1px solid rgba(255,255,255,: absolute; top: 30px; left: 50%; transform: translateX(-50%);
            font-size: 18px; font-weight: bold; color: #00ff88;
            background: rgba(0,0,0,0.6); padding: 5px 20px; border-radius: 20px;
            border: 1px solid rgba(0,255,10.1);
        }
        .guide-item { display: flex; align-items: center; gap: 36,0.3);
            pointer-events: none; z-index: 90;
8px; }
        .icon { font-size: 16px; }

        .loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000;
            display: flex; flex-direction: column;        }

        #ui-container { position: absolute; bottom: 0; left: 0; width: 100%; z-index: 100; pointer-events: none; }
        #ui-panel {
            pointer-events: auto; background: rgba(20, 20,  align-items: center; justify-content: center; z-index: 200;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #00ff88; border-radius20, 0.9);
            padding: 15px; border-radius: 20px 20px 0 0; color: white;
        }
        
        .loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height:: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video>
    <div id="loading" class="loading-mask">
        <div class=" 100%; background: #000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 200;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #00ff88; border-radiusspinner"></div>
        <div style="color:white; font-size: 14px;">åˆå§‹åŒ–æŒ‡æŒ¥: 50%; animation: spin 1s linear infinite; margin-bottom: 15px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        å®˜ç³»ç»Ÿ...</div>
    </div>
    
    <div id="mode-display">WAITING</div>

    <div id="hud-container">
        <div class="hud-item" id="hud-hands">Hands: 0</div>
        <div class="hud-item" id="hud-scale">Scale: 100
        /* é—ªçƒåŠ¨ç”» */
        .flash-action { animation: flashWhite 0.3s; }
        @keyframes flashWhite { 0% { background: #fff; } 100% {%</div>
        <div class="hud-item" id="hud-rot">Rot: 0Â°</div>
        <div class="hud-item" id="hud-cam">View: Front</div>
    </div>

     background: rgba(0, 20, 40, 0.7); } }
    </style>
</head>
<body>

    <video id="input-video" playsinline webkit-playsinline></video<div id="guide-panel">
        <div class="guide-item"><span class="icon">ğŸ–ï¸</span> å•æ‰‹å¼ å¼€: æ—‹è½¬æ¨¡å‹</div>
        <div class="guide-item"><span class="icon">>
    <div id="loading" class="loading-mask">
        <div class="spinner"></div>
        <div style="color:white; font-size: 14px;">åˆå§‹åŒ–æ‰‹åŠ¿ç³»ç»Ÿ...</div>
    </div>
    
    <div id="mode-indicator">ç­‰å¾…æ‰‹åŠ¿...</div>

    <div id="hud-container">
        <div class="hud-item" id="hud-rotate">ğŸ– å•æ‰‹å¼ å¼€: æ—‹è½¬</div>
        <div class="hud-item" id="hud-scale">ğŸ¤² åŒæ‰‹æåˆ: ç¼©æ”¾</div>
        <div class="hud-item" id="hud-pan">âœŠğŸ‘Œ æ¡æ‹³+æ: å¹³ç§»</div>
        <div class="hud-item" id="hud-switch">ğŸ‘ŠğŸ– æ‹³+æŒ: åˆ‡æ¢</div>
        <div class="hud-item" id="hud-view">â˜ï¸âœŒï¸ æ•°å­—: è§†å›¾</div>
        <div class="hud-item" id="hud-lock">ğŸ‘Œ OKæ‰‹åŠ¿: é”å®š</div>
    </div>

    <div id="ui-container">
        <div id="ui-panel">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <h2 style="margin:0; font-size:16px;">æŒ‡ä»¤æ§åˆ¶å°</h2>
                <input type="color" id="color-picker" value="#2f9e44" style="width:40px; height:30px; border:noneğŸ‘</span> åŒæ‰‹æåˆ: ç¼©æ”¾å¤§å°</div>
        <div class="guide-item"><span class="icon">âœŠğŸ¤</span> æ‹³å¤´+æåˆ: å¹³ç§»æ‹–æ‹½</div>
        <div class="guide-item"><span class="icon">â˜ï¸</span> æ‰‹åŠ¿1/2/3: åˆ‡æ¢è§†å›¾</div>
        <div class="guide-item"><span class="icon">âœŠğŸ–ï¸</span> å·¦å³äº’æ: åˆ‡æ¢åœºæ™¯</div>
        <div class="guide-item"><span class="icon">ğŸ‘Œ</span> OKæ‰‹åŠ¿: æš‚åœ/å¼€å¯</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 1. Three.js ---
        const PARTICLE_COUNT = 7500;
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp; background:transparent;">
            </div>
            <select id="shape-select" style="width:100%; padding:10px; background:rgba(255,255,255,02(0x000000, 0.001);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, .15); border:none; border-radius:8px; color:white;">
                <option value="christmas">ğŸ„ åœ£è¯æ ‘</option>
                <option value="heart">ğŸ’– çˆ±å¿ƒ</option>
                <option value="flower">ğŸŒ¸ èŠ±æœµ</option>
                <option value="saturn">ğŸª åœŸæ˜Ÿ</option>
                <option value="buddha">ğŸ§˜ æ‰“å</option>
                <option value="1000);
        // åˆå§‹ç›¸æœºä½ç½®
        let targetCamPos = new THREE.Vector3(0, 0, 30);
        camera.position.copy(targetCamPos);

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatiofireworks">ğŸ† çƒŸèŠ±</option>
            </select>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/, 2));
        document.body.appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        for(letcamera_utils/camera_utils.js"></script>
    <script src="https://unpkg.com/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https:// i=0; i<PARTICLE_COUNT*3; i++) { positions[i] = (Math.random()-0.5)*100; targetPositions[i]=positions[i]; }
        geometry.unpkg.com/@mediapipe/hands/hands.js"></script>

    <script>
        // --- 1. Three.js åˆå§‹åŒ– ---
        const PARTICLE_COUNT = 7500;
setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({ color: 0x2f9e44, size: 0.25, transparent:        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);
        
        const camera = new THREE. true, opacity: 0.8, blending: THREE.AdditiveBlending });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- å½¢çŠ¶åº“ ---
        PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // è§†å›¾ä½ç½®é¢„è®¾
        const VIEWS = {
            FRONT: { x: 0, y: 0, z: 25 },
            SIDE:  { x: 25, yconst Shapes = {
            christmas: () => {
                const arr = []; for (let i = 0; i < PARTICLE_COUNT; i++) {
                    const p = Math.random(); let x,y,z;
                    if (p > 0.92) { const r=Math.random()*2: 0, z: 0 },
            TOP:   { x: 0, y: 25, z: 1 } // zä¸èƒ½å®Œå…¨ä¸º0ï¼Œå¦åˆ™lookAtä¼šå‡ºé—®é¢˜
        };
        let currentViewTarget = { ...VIEWS.FRONT };
        camera.position.set(0, 0, 25);, t=Math.random()*6.28, f=Math.random()*3.14; x=r*Math.sin(f)*Math.cos(t); y=r*Math.sin(f)*Math.sin(t)+13; z=r*Math.cos(f); } 
                    else { const h=Math.random()*22-9, maxR=9*(1-(h+9)/2

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const geometry =2), r=Math.random()*maxR, a=(h+9)*2.5+Math.random()*6.28; x=r*Math.cos(a); z=r*Math.sin(a); y=h; }
                    arr.push(x, y, z);
                } material.color.set new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        for(let i=0; i<PARTICLE_COUNT*3; i++) { positions[i] = (Hex(0x2f9e44); return arr;
            },
            heart: () => {
                const arr=[]; for(let i=0;i<PARTICLE_COUNT;i++) {
                    let t=Math.random()-0.5)*100; targetPositions[i]=positions[i]; }
        Math.random()*6.28, x=16*Math.pow(Math.sin(t),3), y=13*Math.cos(t)-5*Math.cos(2*t)-2geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({ color: 0x2f9e44, size: 0.25, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
        const particles = new*Math.cos(3*t)-Math.cos(4*t); arr.push(x*0.5,y*0.5,(Math.random()-0.5)*5);
                } material.color.setHex(0xff0055); return arr;
            },
            saturn: () => { THREE.Points(geometry, material);
        scene.add(particles);

        // --- å½¢çŠ¶æ•°æ® ---
        const Shapes = {
            christmas: () => {
                const arr = []; for (let i=0; i<PARTICLE_COUNT; i++) {
                    const p=Math.random(); let x,y
                const arr=[]; for(let i=0;i<PARTICLE_COUNT;i++) {
                    let x,y,z; if(Math.random()>0.4){let r=7,t=Math.random()*6.28,f=Math.acos(2*Math.random()-1);x,z;
                    if(p>0.92){const r=Math.random()*2,t=Math.random()*6.28,f=Math.random()*3.14;x=r*Math.=r*Math.sin(f)*Math.cos(t);y=r*Math.sin(f)*Math.sin(t);z=r*Math.cos(f);}
                    else{let a=sin(f)*Math.cos(t);y=r*Math.sin(f)*Math.sin(t)+13;z=r*Math.cos(f);}
                    else{const h=Math.random()*22-9,maxR=9*(1-(h+9)/22),r=MathMath.random()*6.28,d=10+Math.random()*6;x=Math.cos(a)*d;y=Math.sin(a)*d;z=(Math.random()-0.5)*0.5;let ty=y;y=ty*Math.cos(0.5)-z.random()*maxR,a=(h+9)*2.5+Math.random()*6.28;x=r*Math.cos(a);z=r*Math.sin(a);y=h*Math.sin(0.5);z=ty*Math.sin(0.5)+z*Math.cos(0.5);}
                    arr.push(x,y,z);
                } material.;}
                    arr.push(x,y,z);
                } updateColor("#2f9e44color.setHex(0xffaa55); return arr;
            },
            fireworks: () =>"); return arr;
            },
            heart: () => {
                const arr=[]; for(let i=0;i<PARTICLE_COUNT;i++) {
                    let t=Math.random()*6.28 {
                const arr=[]; for(let i=0;i<PARTICLE_COUNT;i++) {
                    let r=Math.pow(Math.random(),0.5)*15,t=Math.random, x=16*Math.pow(Math.sin(t),3), y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math()*6.28,f=Math.acos(2*Math.random()-1); arr.push(r*Math.sin(f)*Math.cos(t),r*Math.sin(f)*Math..cos(4*t);
                    arr.push(x*0.5,y*0.5,(Math.random()-0.5)*5);
                } updateColor("#ff0055"); return arr;
            },
            flower: () => {
                const arr=[]; for(let i=0;i<PARTICLE_COUNT;i++) {
                    let t=Math.random()*6.28,sin(t),r*Math.cos(f));
                } material.color.setHex(0x00ffff); return arr;
            }
        };

        const shapeKeys = Object.keys(Shapes);
        let currentShapeIndex = 0;

        function updateShape(key) {
            if(!Shapes[key]) return;
            const newPos = Shapes[key]();
            const explosionRange =  f=Math.random()*3.14, r=8*Math.cos(4*t)+4150; 
            const currentPosAttr = particles.geometry.attributes.position.array;
            ;
                    arr.push(r*Math.sin(f)*Math.cos(t),r*Math.sin(f)*Math.sin(t),r*Math.cos(f)*0.5);
                } updateColor("#ff00ff"); return arr;
            },
            saturn: () => {
                const arr=[]; for(let i=0;i<PARTICLE_COUNT;i++) {
                    let x,y,z; if(Math.random()>0.4){let r=7,t=for(let i=0; i < targetPositions.length; i++) {
                targetPositions[i] = newPos[i];
                currentPosAttr[i] = (Math.random() - 0.5) * explosionRange;
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }
        updateShape('christmas');

        // --- çŠ¶æ€ä¸åŠ¨ç”»å˜é‡ ---
        let sys = {
            active: true,
            scale: 1.0,
            rotY: 0,Math.random()*6.28,f=Math.acos(2*Math.random()-1);x=r*Math.sin(f)*Math.cos(t);y=r*Math.sin(f
            panX: 0,
            panY: 0,
            lastSwitchTime: 0
        };
        // æ¸²æŸ“ç›®æ ‡å€¼ (ç”¨äºæ’å€¼)
        let render = { scale: 1.0)*Math.sin(t);z=r*Math.cos(f);}
                    else{let a=Math.random()*6.28,d=10+Math.random()*6;x=Math.cos(a)*d;y=Math.sin(a)*d;z=(Math.random()-0.5)*0.5;let ty=y;y=ty*Math.cos(0.5)-z*Math, rotY: 0, panX: 0, panY: 0 };

        function animate() {
            requestAnimationFrame(animate);
            const pos = particles.geometry.attributes.position.array;
            
            // ç¼“åŠ¨æ’å€¼
            render.scale += (sys.scale - render.scale) * 0.1;
            render.rotY += (sys.rotY - render.rotY) * 0.1;
            render.panX += (sys.panX - render.panX).sin(0.5);z=ty*Math.sin(0.5)+z*Math.cos * 0.1;
            render.panY += (sys.panY - render.panY)(0.5);}
                    arr.push(x,y,z);
                } updateColor("#ffaa55"); return arr;
            },
            buddha: () => {
                const arr=[]; for( * 0.1;
            
            // ç›¸æœºä½ç½®å¹³æ»‘ç§»åŠ¨
            camera.position.lerp(targetCamPos, 0.05);
            camera.lookAt(0,0,0let i=0;i<PARTICLE_COUNT;i++) {
                    let p=Math.random(),t=Math.random()*6.28,f=Math.acos(2*Math.random()-1);

            // ç²’å­æ›´æ–°
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                let tx = targetPositions[idx] * render),r,x,y,z;
                    if(p<0.25){r=2..scale; 
                let ty = targetPositions[idx+1] * render.scale; 
                5;y=r*Math.sin(f)*Math.sin(t)+6;}else if(p<0.65){r=4.5;y=r*Math.sin(f)*Math.let tz = targetPositions[idx+2] * render.scale;
                
                // æ—‹è½¬çŸ©é˜µé€»è¾‘sin(t);}else{r=6;f=Math.random()*3.14;y=r*Math.sin(f)*Math.sin(t)*0.5-4;}
                    x=r (ç®€å•çš„Yè½´æ—‹è½¬)
                const cosR = Math.cos(render.rotY);
                const sinR = Math.sin(render.rotY);
                const rx = tx * cosR - tz * sinR;
                const rz = tx * sinR + tz * cosR;
                tx = rx; tz = rz;

                pos[idx] += (tx - pos[idx]) * 0.1; 
*Math.sin(f)*Math.cos(t);z=r*Math.cos(f);
                    arr.push(x,y,z);
                } updateColor("#ffaa00"); return arr;
            },
            fireworks: () => {
                const arr=[]; for(let i=0;                pos[idx+1] += (ty - pos[idx+1]) * 0.1; 
                pos[idx+2] += (tz - pos[idx+2]) * 0.1;i<PARTICLE_COUNT;i++) {
                    let r=Math.pow(Math.random(),0.5)*15,t=Math.random()*6.28,f=Math.acos(2
            }
            
            particles.position.x = render.panX;
            particles.position.y = render.panY;

            particles.geometry.attributes.position.needsUpdate = true;
            *Math.random()-1);
                    arr.push(r*Math.sin(f)*Math.cos(t),r*Math.sin(f)*Math.sin(t),r*Math.cos(f));
                } updateColor("#00ffff"); return arr;
            }
        };

        const shaperenderer.render(scene, camera);
        }
        animate();

        // ------------------------------------------------------------------
        // ğŸš€ æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ (Gesture Logic)
        // ------------------------------------------------------------------
        
        constKeys = Object.keys(Shapes);
        let currentShapeIndex = 0;
        function updateColor(hex) { material.color.set(hex); document.getElementById('color-picker').value = hex; } videoElement = document.getElementById('input-video');
        const loadingDiv = document.getElementById('loading');
        const modeDisplay = document.getElementById('mode-display');
        
        // HUD Elements
        const uiHands = document.
        
        function updateShape(key) {
            if(!Shapes[key]) return;
            const newPos = Shapes[key]();
            const explosionRange = 150; 
            const currentgetElementById('hud-hands');
        const uiScale = document.getElementById('hud-scale');
        const uiRot = document.getElementById('hud-rot');
        const uiCam = document.getElementById('hud-cam');PosAttr = particles.geometry.attributes.position.array;
            for(let i=0; i < targetPositions.length; i++) {
                targetPositions[i] = newPos[i];
                current

        // é…ç½®ï¼šæ£€æµ‹ä¸¤åªæ‰‹
        const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands:PosAttr[i] = (Math.random() - 0.5) * explosionRange;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            document.getElementById('shape-select 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        // åŒå‡»é‡ç½®ç›¸å…³
        let lastPinchTime = 0;
        ').value = key;
        }
        updateShape('christmas');

        // --- æ ¸å¿ƒçŠ¶æ€å¯¹è±¡ ---
        const State = {
            scale: 1.0,
            rotationY: 0,
            posXlet lastReleaseTime = 0;
        
        // ç¼©æ”¾åŸºå‡†
        let initialPinchDist = 0;
        let initialScale = 1;
        
        // å¹³ç§»åŸºå‡†
        let pan: 0,
            posY: 0,
            isLocked: false // OKæ‰‹åŠ¿æš‚åœ
        };
        const TargetState = { ...State };

        function animate() {
            requestAnimationFrame(animate);
            const pos = particles.geometry.attributes.position.array;
            
            // 1. å¹³æ»‘æ’å€¼ (LerStart = { x: 0, y: 0, objX: 0, objY: 0 };
        
        // æ—‹è½¬åŸºå‡†
        let rotStartX = 0;
        let initialRotYp)
            State.scale += (TargetState.scale - State.scale) * 0.1;
            State.rotationY += (TargetState.rotationY - State.rotationY) * 0.1; = 0;

        // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ‰‹åŠ¿
        function isPinching(lm) {
            const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y
            State.posX += (TargetState.posX - State.posX) * 0.1;
            State.posY += (TargetState.posY - State.posY) * 0.1;
            
             - lm[8].y);
            const size = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y); // æ‰‹æŒå¤§å°
            return (dist / size) < 0.25;
        }

        function isFist(lm) {// 2. æ‘„åƒæœºè§†å›¾å¹³æ»‘åˆ‡æ¢
            camera.position.x += (currentViewTarget.x - camera.position.x) * 0.05;
            camera.position.y += (currentViewTarget.y - camera.position.y) * 0.05;
            camera.position
            // ç®€å•åˆ¤æ–­ï¼šæŒ‡å°–(8,12,16,20)æ˜¯å¦æ¥è¿‘æŒ.z += (currentViewTarget.z - camera.position.z) * 0.05;
            camera.lookAt(0,0,0);

            // 3. ç²’å­æ¸²æŸ“
            forå¿ƒ(0)æˆ–æŒ‡æ ¹
            // è¿™é‡Œåˆ¤æ–­æŒ‡å°–æ˜¯å¦ä½äºç¬¬äºŒå…³èŠ‚ (yåæ ‡æ¯”è¾ƒï¼Œæ³¨æ„å€’ç½®)
            // æ›´é€šç”¨çš„ï¼šåˆ¤æ–­æŒ‡å°–åˆ°è…•éƒ¨è·ç¦» < æŒ‡æ ¹åˆ°è…•éƒ¨è·ç¦» ( (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                let tx = targetPositions[idx] * State.scale; 
                let ty = targetPositions[idx+1] * State.scale; 
                let tz = targetPositions[idx+2å¼¯æ›²)
            const fingers = [8, 12, 16, 20];
            let foldedCount = 0;
            const wrist = lm[0];
            fingers.forEach(tip => {
                ] * State.scale;
                
                if (shapeKeys[currentShapeIndex] === 'fireworks') { 
                    tx+=(Math.random()-0.5)*0.2; ty+=(Math.const base = lm[tip - 3]; // MCP joint
                const distTip = Math.hypot(lm[tip].x - wrist.x, lm[tip].y - wrist.y);
                const distrandom()-0.5)*0.2; tz+=(Math.random()-0.5)*0.2; 
                }
                pos[idx] += (tx - pos[idx]) * 0.1Base = Math.hypot(base.x - wrist.x, base.y - wrist.y);
                if (distTip < distBase * 1.1) foldedCount++; // 1.1 å®¹å·®; 
                pos[idx+1] += (ty - pos[idx+1]) * 0.1; 
                pos[idx+2] += (tz - pos[idx+2]) * 0.1;
            }
            
            particles.rotation.y = State.rotationY;
            particles.position.x = State.posX;
            particles.position.y = State.posY;
            
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // ------------------------------------------------------------------
        // ğŸš€ é«˜çº§æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
        // ------------------------------------------------------------------
        
        // è¾…åŠ©å˜é‡
        let prevPinchDist = 0;
        let prevPanCenter = { x: 0, y: 0 };
        let prevOpenX = 0;
        
        let lastSwitchTime = 0;
        let lastOkTime = 0;
        let lastPinchTime = 0;
        const DEBOUNCE = 500; // é˜²æŠ–æ—¶é—´
        const DOUBLE_PINCH_DELAY = 400; // åŒå‡»é—´éš”

        // HUD å…ƒç´ 
        const modeIndicator = document.getElementById('mode-indicator');
        const hudItems = {
            rotate: document.getElementById('hud-rotate'),
            scale: document.getElementById('hud-scale'),
            pan: document.getElementById('hud-pan'),
            switch: document.getElementById('hud-switch'),
            view: document.getElementById('hud-view'),
            lock: document.getElementById('hud-lock')
        };

        function activateHud(key) {
            Object.values(hudItems).forEach(el => el.classList.remove('active'));
            if(hudItems[key]) hudItems[key].classList.add('active');
        }

        const hands = new Hands({locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2
            });
            // æ‹‡æŒ‡å•ç‹¬åˆ¤æ–­
            const thumbTip = lm[4];
            const thumbBase = lm[2];
            // æ‹³å¤´åˆ¤å®šï¼š4æŒ‡å¼¯æ›²
            return foldedCount >= 3; 
        }

        function isOpen(lm) {
            const fingers = [8, 12, 16, 20];
            let openCount = 0;
            const wrist = lm[0];
            fingers.forEach(tip => {
                const base = lm[tip - 3];
                const distTip = Math.hypot(lm[tip].x - wrist.x, lm[tip].y - wrist.y);
                const distBase = Math.hypot(base.x - wrist.x, base.y - wrist.y);
                if (distTip > distBase) openCount++;
            });
            // å¿…é¡»5æŒ‡å¼ å¼€
            const thumbTip = lm[4];
            const thumbIdx = lm[5]; // é£ŸæŒ‡æ ¹
            const distThumb = Math.hypot(thumbTip.x - wrist.x, thumbTip.y - wrist.y);
            const distIdx = Math.hypot(thumbIdx.x - wrist.x, thumbIdx.y - wrist.y);
            
            return openCount === 4 && distThumb > distIdx * 0.5;
        }

        function getFingerCount(lm) {
            // è®¡ç®—ä¼¸å‡ºçš„æ‰‹æŒ‡æ•°é‡
            let count = 0;
            const wrist = lm[0];
            // é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡
            [8, 12, 16, 20].forEach(tip => {
                if (lm[tip].y < lm[tip, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        
        // --- æ‰‹åŠ¿åˆ¤å®šè¾…åŠ©å‡½æ•° ---
        function isPinching(lm) {
            const dist-2].y) count++; // ç®€å•çš„Yè½´åˆ¤æ–­(æ‰‹å‘ä¸Šæ—¶)
            });
            //  = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
            const handSize = Math.hypot(lm[0].x - lmæ‹‡æŒ‡ Xè½´åˆ¤æ–­
            // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–ç‰ˆï¼Œå‡è®¾æ‰‹æ˜¯æ­£å‘çš„
            return count;
        }
        
        function isOKGesture(lm) {
            // æ‹‡æŒ‡(4)å’Œé£ŸæŒ‡(8[9].x, lm[0].y - lm[9].y);
            return (dist / handSize) < 0.25;
        }
        function isFist(lm) {
            //)æ¥è§¦ï¼Œå…¶ä»–ä¸‰æŒ‡ä¼¸ç›´
            const pinch = isPinching(lm);
            const midUp = lm[12].y < lm[10].y;
            const ringUp = lm[1 ç®€å•åˆ¤å®šï¼šæŒ‡å°–(8,12,16,20)éƒ½æ¯”æŒ‡æ ¹(5,9,13,17)æ›´é è¿‘æŒå¿ƒ(0)
            return lm[8].y > lm6].y < lm[14].y;
            return pinch && midUp && ringUp;
        }

        hands.onResults((results) => {
            if(loadingDiv.style.opacity !== '[6].y && lm[12].y > lm[10].y && lm[16].0') { loadingDiv.style.opacity = '0'; setTimeout(() => loadingDiv.style.display = 'y > lm[14].y && lm[20].y > lm[18].y;
        }
        function isOpen(lm) {
            return !isFist(lm) && !isPnone', 500); }

            const handsFound = results.multiHandLandmarks ? results.multiHandLandmarks.length : 0;
            uiHands.innerText = `Hands: ${handsFound}`;

            inching(lm);
        }
        function countFingers(lm) {
            let count = 0;
            // æ‹‡æŒ‡(xæ¯”è¾ƒç‰¹æ®Šï¼Œè¿™é‡Œç®€åŒ–ï¼Œåªç®—4æŒ‡)
            if// é‡ç½®çŠ¶æ€æ˜¾ç¤ºé¢œè‰²
            document.querySelectorAll('.hud-item').forEach(el => el.classList.remove('active'));

            if (handsFound > 0) {
                const lm1 = results.multiHandLandmarks[0];
                const handedness1 = results.multiHandedness[0].label; // Left or(lm[8].y < lm[6].y) count++;
            if(lm[12].y < lm[10].y) count++;
            if(lm[16].y < lm[14].y) count++;
            if(lm[20].y < lm[18].y Right
                
                // --- 5. OK æ‰‹åŠ¿ (å…¨å±€å¼€å…³) ---
                if (handsFound === 1) count++;
            return count;
        }
        function isOkGesture(lm) {
            // æ‹‡æŒ‡é£ŸæŒ‡æåˆï¼Œå…¶ä»–æ‰‹æŒ‡ä¼¸ç›´
            const pinch = Math.hypot(lm[4]. && isOKGesture(lm1)) {
                    // é˜²æŠ–å¤„ç†
                    const now = Date.now();
                    if (now - sys.lastSwitchTime > 1000) {
                        sys.active = !x - lm[8].x, lm[4].y - lm[8].y) < 0.sys.active;
                        modeDisplay.innerText = sys.active ? "SYSTEM ACTIVE" : "SYSTEM PAUSED";
                        modeDisplay.className = sys.active ? "" : "paused";
                        sys.lastSwitchTime = now05;
            const middleUp = lm[12].y < lm[10].y;
            const ringUp = lm[16].y < lm[14].y;
            return pinch && middleUp && ringUp;
        }

        hands.onResults((results) => {
            const now = Date.now();
            document.getElementById('loading').style.display = 'none';

            const detected;
                    }
                    return; // è¯†åˆ«åˆ°å¼€å…³æ‰‹åŠ¿ï¼Œä¸è¿›è¡Œå…¶ä»–æ“ä½œ
                }

                if (!sys.active) return; // æš‚åœçŠ¶æ€

                // è·å–åŒæ‰‹æ•°æ® (å¦‚æœæœ‰)
                let leftHands = results.multiHandLandmarks;
            const handedness = results.multiHandedness; // label: 'Left' or 'Right'
            
            if (!detectedHands || detectedHands.length === 0) {Hand = null;
                let rightHand = null;

                for (let i = 0; i < handsFound; i++) {
                    const label = results.multiHandedness[i].label;
                    const lm =
                modeIndicator.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                activateHud('');
                prevPinchDist = 0; prevOpenX = 0;
                return;
            }

            // --- 0.  results.multiHandLandmarks[i];
                    if (label === 'Left') leftHand = lm;
                    else rightHand = lm;
                }

                // ==========================================
                //  åŒ æ‰‹ æ“ ä½œ (é”å®šæ£€æµ‹ (ä¼˜å…ˆçº§æœ€é«˜) ---
            // ä»»æ„ä¸€åªæ‰‹åš OK æ‰‹åŠ¿è§¦å‘é”å®š
            for (ä¼˜å…ˆçº§æœ€é«˜)
                // ==========================================
                if (leftHand && rightHand) {
                    const leftPinch = isPinching(leftHand);
                    const rightPinch = isPinching(rightHandlet i = 0; i < detectedHands.length; i++) {
                if (isOkGesture();
                    const leftFist = isFist(leftHand);
                    const rightFist = isFdetectedHands[i]) && (now - lastOkTime > 1000)) {
                    TargetState.isLocked = !TargetState.isLocked;
                    lastOkTime = now;
                    modeIndicator.innerText = TargetState.isLocked ? "ğŸ”’ ç³»ç»Ÿå·²é”å®š" : "ğŸ”“ ç³»ç»Ÿå·²è§£é”";
                    hudItems.ist(rightHand);
                    const leftOpen = isOpen(leftHand);
                    const rightOpen = isOpen(rightHand);

                    // --- 6. åˆ‡æ¢ç”»é¢ (æ‹³å¤´ + å¼ å¼€) ---
                    // å·¦æ‰‹æ‹³ + å³æ‰‹å¼ å¼€ -> ä¸‹ä¸€å¼ 
                    if (leftFist && rightOpen) {
lock.classList.add('flash-action');
                    setTimeout(()=>hudItems.lock.classList.remove('flash-action'), 300);
                }
            }
            
            if (TargetState.isLocked                        const now = Date.now();
                        if (now - sys.lastSwitchTime > 1000) {
                            currentShapeIndex = (currentShapeIndex + 1) % shapeKeys.length;
) {
                activateHud('lock');
                return; // é”å®šçŠ¶æ€ä¸‹ä¸å¤„ç†å…¶ä»–æ‰‹åŠ¿
            }

            // ============================
            //   åŒæ‰‹æ“ä½œé€»è¾‘ (2 Hands)
            // ============================
            if                            updateShape(shapeKeys[currentShapeIndex]);
                            modeDisplay.innerText = "NEXT SCENE >>";
                            sys.lastSwitchTime = now;
                        }
                    }
                    // å³æ‰‹æ‹³ + å·¦æ‰‹å¼ å¼€ -> ä¸Šä¸€å¼ 
                    else if (rightFist && leftOpen) {
                        const now = Date.now (detectedHands.length === 2) {
                const hand1 = detectedHands[0];
                const hand2 = detectedHands[1];
                const type1 = handedness[0].label; // 'Left' or 'Right'
                const type2 = handedness[1].label;
                
                const is();
                        if (now - sys.lastSwitchTime > 1000) {
                            currentShapeIndex = (currentShapeIndex - 1 + shapeKeys.length) % shapeKeys.length;
                            updateShape(shapeKeys[currentShapeIndex]);
                            modeDisplay.innerText = "<< PREV SCENE";
                            Pinch1 = isPinching(hand1);
                const isPinch2 = isPinching(hand2);
                const isFist1  = isFist(hand1);
                const isFist2  sys.lastSwitchTime = now;
                        }
                    }
                    
                    // --- 2. = isFist(hand2);
                const isOpen1  = isOpen(hand1);
                const isOpen2  = isOpen(hand2);

                // --- 6 & 7. æ‹³æŒåˆ‡æ¢å›¾å½¢ ---ç¼©æ”¾æ¨¡å‹ (åŒ Pinch) ---
                    else if (leftPinch && rightPinch) {
                        modeDisplay.innerText = "MODE: ZOOM";
                        uiScale.classList.add('active');
                        
                        // è®¡ç®—ä¸¤æ‰‹è·ç¦»
                        const handDist = Math.hypot(leftHand[9].x - rightHand[9].x
                // æ³¨æ„ï¼šMediaPipe é•œåƒåï¼Œç”»é¢å·¦è¾¹æ˜¯ Right Handï¼Œå³è¾¹æ˜¯ Left Hand
                , leftHand[9].y - rightHand[9].y);
                        
                        // éœ€è¦ä¸€ä¸ªçŠ¶æ€é”æ¥è®°å½•åˆå§‹è·ç¦»
                        if (!window.isZooming) {
                            window.isZooming = true;
                            initialPinchDist = handDist;
                            initialScale = sys.scale;
                        }
                        
                        const ratio = handDist / (initialPinchDist || 0.1);
                        sys.scale = Math.max(0.1, Math.min(initialScale * ratio, 5.0));
                        uiScale.innerText = `Scale: ${Math.round(sys.scale * 100)}%`;

                    } else {
                        window.isZooming = false;
                    }

                    // --- 3. å¹³ç§»æ¨¡å‹ (ä¸€æ‹³ + ä¸€æ) ---
                    // é€»è¾‘ï¼šæçš„æ‰‹æ˜¯é”šç‚¹ï¼Œæ‹³çš„æ‰‹ä¹Ÿæ˜¯é”šç‚¹ï¼Œå–ä¸­ç‚¹ç§»åŠ¨
                    // æˆ–è€…ï¼šç®€åŒ–ä¸ºåªè¦æ»¡è¶³æ¡ä»¶å°±è¿½è¸ªä¸¤æ‰‹ä¸­å¿ƒ
                    if ((leftPinch && rightFist) || (rightPinch && leftFist)) {
                        modeDisplay.innerText = "// é€»è¾‘ï¼šLeft Fist + Right Open -> Next
                // é€»è¾‘ï¼šRight Fist + Left Open -> Prev
                
                // æ‰¾åˆ°å…·ä½“çš„å·¦å³æ‰‹
                let leftHand = (type1 === 'Left') ? hand1 : hand2;
                let rightHand = (type1 === 'Right') ? hand1 : hand2;
                
                if (now - lastSwitchTime > DEBOUNCE) {
                    if (isFist(leftHand) && isOpen(rightHand)) {
                        // å·¦æ‹³å³æŒ -> Next
                        currentShapeIndex = (currentShapeIndex + 1) % shapeKeys.length;
                        updateShape(shapeKeys[currentShapeIndex]);
                        modeIndicator.innerText = "â© åˆ‡æ¢: ä¸‹ä¸€ä¸ª";
                        activateHud('switch');
                        lastSwitchTime = now;
                        return;
                    } 
                    if (isFist(rightHand) && isOpen(leftHand)) {
                        // å³æ‹³å·¦æŒ -> Prev
                        currentShapeIndex = (currentShapeIndex - 1 + shapeKeys.length) % shapeKeys.length;
                        updateShape(shapeKeys[currentShapeIndex]);
                        modeIndicatorMODE: PAN";
                        
                        // è®¡ç®—ä¸¤æ‰‹ä¸­ç‚¹
                        const centerX = (leftHand[9].x + rightHand[9].x) / 2;
                        const centerY = (leftHand[9]..innerText = "âª åˆ‡æ¢: ä¸Šä¸€ä¸ª";
                        activateHud('switch');
                        lastSwitchTime = now;
                        return;
                    }
                }

                // --- 2. åŒæ‰‹æåˆ:y + rightHand[9].y) / 2;
                        
                        if (!window.isPanning) {
                            window.isPanning = true;
                            panStart.x = centerX;
                            panStart.y = ç¼©æ”¾ ---
                if (isPinch1 && isPinch2) {
                    const currDist = Math.hypot(hand1[9].x - hand2[9].x, hand1[9].y - centerY;
                            panStart.objX = sys.panX;
                            panStart.objY = sys.panY;
                        }
                        
                        const sensitivity = 40;
                        sys.panX = panStart.objX + (centerX - panStart.x) * -sensitivity;
                        sys.panY = panStart.objY + (centerY - panStart.y) * -sensitivity;

                    } else {
                        window hand2[9].y);
                    if (prevPinchDist > 0) {
                        const delta = currDist - prevPinchDist;
                        TargetState.scale += delta * 2; // ç¼©æ”¾ç³»æ•°
                        TargetState.scale = Math.max(0.2, Math.min(TargetState.scale,.isPanning = false;
                    }
                } 
                
                // ==========================================
                //  å• æ‰‹ æ“ ä½œ (ä¼˜å…ˆçº§ä½)
                // ==========================================
                else if (handsFound === 4.0));
                    }
                    prevPinchDist = currDist;
                    modeIndicator.innerText = `ğŸ” ç¼©æ”¾: ${Math.round(TargetState.scale*100)}%`;
                    activateHud('scale');
                    return;
                } else {
                    prevPinchDist = 0;
 1) {
                    const lm = lm1;
                    const pinch = isPinching(lm);
                }

                // --- 3. å•æ‰‹æ + å•æ‰‹æ‹³: å¹³ç§» ---
                if ((isPinch                    const open = isOpen(lm);
                    const fingers = getFingerCount(lm);

                    // --- 7. åŒæé‡ç½® (ä¿ç•™åŠŸèƒ½) ---
                    const now = Date.now();
                    if (pinch)1 && isFist2) || (isPinch2 && isFist1)) {
                    // è®¡ç®—åŒæ‰‹ä¸­å¿ƒç‚¹
                    const centerX = (hand1[9].x + hand2[9].x) / {
                         // æ£€æµ‹åŒå‡»
                         if (!window.isSinglePinching) {
                            if (now - lastPinchTime < 400 && now - lastReleaseTime > 50) {
                                // Double Pinch Triggered
                                sys.scale = 1.0; sys.panX = 0; sys.panY 2;
                    const centerY = (hand1[9].y + hand2[9].y) / 2;
                    
                    if (prevPanCenter.x !== 0) {
                        const dx = (centerX - prevPanCenter.x) * -40; // çµæ•åº¦
                        const dy = (centerY - prev = 0; sys.rotY = 0;
                                modeDisplay.innerText = "!!! RESET !!!";
                                targetCamPos.set(0,0,30); // é‡ç½®ç›¸æœº
                            }
                            window.isPanCenter.y) * -40;
                        TargetState.posX += dx;
                        TargetState.posY += dy;
                    }
                    prevPanCenter = { x: centerX, y: centerY };
                    modeIndicator.innerText = "â†”ï¸ å¹³ç§»æ¨¡å‹";
                    activateHud('pan');
                    return;
                } elseSinglePinching = true;
                            lastPinchTime = now;
                         }
                    } else {
                        if (window.isSinglePinching) {
                            window.isSinglePinching = false;
                            last {
                    prevPanCenter = { x: 0, y: 0 };
                }
            }

            // ============================
            //   å•æ‰‹æ“ä½œé€»è¾‘ (1 Hand)
            // ============================
            ReleaseTime = now;
                        }
                    }

                    // --- 1. æ—‹è½¬æ¨¡å‹ (å•æ‰‹å¼ å¼€ + ç§»åŠ¨) ---
                    if (open) {
                        modeDisplay.innerText = "MODE: ROTelse if (detectedHands.length === 1) {
                const hand = detectedHands[0];
                const fingers = countFingers(hand);
                const isPinch = isPinching(hand);

                // --- ATE";
                        uiRot.classList.add('active');
                        
                        const currentX = lm[9].x;
                        if (!window.isRotating) {
                            window.isRotating = true;
                            rotStartX4. æ•°å­—æ‰‹åŠ¿: åˆ‡æ¢è§†å›¾ ---
                if (!isPinch && !isFist(hand)) {
                    if (fingers === 1) {
                        currentViewTarget = { ...VIEWS.FRONT };
 = currentX;
                            initialRotY = sys.rotY;
                        }
                        
                        // å·¦å³ç§»åŠ¨æ§åˆ¶ Yè½´æ—‹è½¬
                        const delta = (currentX - rotStartX) * 5; //                         modeIndicator.innerText = "ğŸ“º æ­£è§†å›¾";
                        activateHud('view');
                    } else if (fingers === 2) {
                        currentViewTarget = { ...VIEWS.SIDE };
                        modeIndicator.çµæ•åº¦
                        sys.rotY = initialRotY + delta;
                        uiRot.innerText = `Rot:innerText = "ğŸ“º ä¾§è§†å›¾";
                        activateHud('view');
                    } else if (fingers === ${Math.round(sys.rotY * (180/Math.PI))}Â°`;
                    } else {
 3) {
                        currentViewTarget = { ...VIEWS.TOP };
                        modeIndicator.innerText = "ğŸ“º ä¿¯è§†å›¾";
                        activateHud('view');
                    }
                }

                // --- 1                        window.isRotating = false;
                    }

                    // --- 4. åˆ‡æ¢è§†å›¾ (æ•°å­—æ‰‹åŠ¿) ---
                    // åªæœ‰åœ¨éæåˆã€éå…¨å¼ å¼€æ—¶æ£€æµ‹æ•°å­—
                    if (!pinch && !open) {
                        if (fingers === 1) {
                            modeDisplay.innerText = "VIEW. å•æ‰‹å¼ å¼€ + ç§»åŠ¨: æ—‹è½¬ ---
                if (isOpen(hand)) {
                    const currX = hand[9].x;
                    if (prevOpenX !== 0) {
                        const dx: FRONT";
                            targetCamPos.set(0, 0, 30);
                            uiCam.innerText = "View: Front";
                            uiCam.classList.add('active');
                        } else if (fing = currX - prevOpenX;
                        if (Math.abs(dx) > 0.005) { // é˜ˆå€¼
                            TargetState.rotationY += dx * 5; // æ—‹è½¬é€Ÿåº¦
                            modeIndicatorers === 2) {
                            modeDisplay.innerText = "VIEW: SIDE";
                            targetCamPos.set(30, 0, 0); // ä¾§é¢
                            uiCam.innerText = "View.innerText = "ğŸ”„ æ—‹è½¬æ¨¡å‹";
                            activateHud('rotate');
                        }
                    }
                    prevOpenX = currX;
                } else {
                    prevOpenX = 0;
                }: Side";
                            uiCam.classList.add('active');
                        } else if (fingers === 3) {
                            modeDisplay.innerText = "VIEW: TOP";
                            targetCamPos.set(0

                // --- 8. Double Pinch Reset (å¤ä½) ---
                if (isPinch) {
                    if (now - lastPinchTime > 50 && now - lastPinchTime < DOUBLE_PINCH_DELAY) {
                         // åŒå‡»è§¦å‘
                         TargetState.scale = 1.0;
                         Target, 30, 1); // é¡¶éƒ¨ (ç•¥å¾®åä¸€ç‚¹é˜²æ­¢LookAtæŠ¥é”™)
                            uiCam.innerText = "View: Top";
                            uiCam.classList.add('active');
                        }
State.posX = 0;
                         TargetState.posY = 0;
                         TargetState.rotationY = 0                    }
                }
            } else {
                // æ²¡æœ‰æ‰‹
                modeDisplay.innerText = "WAITING...";
                window.isZooming = false;
                window.isPanning = false;
                window;
                         currentViewTarget = { ...VIEWS.FRONT };
                         modeIndicator.innerText = "âš¡ï¸ ç³»ç»Ÿé‡ç½®";
                         modeIndicator.style.color = "red";
                         setTimeout(()=>modeIndicator.style..isRotating = false;
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 480, height: 360, facingMode: 'user'
        });
        cameraUtilscolor = "#00ff88", 500);
                    }
                    lastPinchTime = now;
                }
            }
        });

        // å¯åŠ¨
        const cameraUtils = new Camera(document.getElementById('input-video'), {
            onFrame: async () => await hands.send({image:.start().catch(e=>console.error(e));

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window. document.getElementById('input-video')}),
            width: 640, height: 480, facingMode: 'user'
        });
        cameraUtils.start();

        window.addEventListener('resize', () =>innerWidth, window.innerHeight); });

    </script>
</body>
</html>
